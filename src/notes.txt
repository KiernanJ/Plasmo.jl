# Motivation
- The idea for the new Plasmo.jl rewrite is to create our own MOI interface for an OptiGraph

## Why we can't just extend or wrap a JuMP.Model
- No way to handle linking between subproblems (in JuMP, variables in constraints must be owned by their model)
- Less prone to user 'messing things up' by working directly with a 'Model'
- More flexibility creating our own MOI interface: We could use either MOI or GOI backends
- No real reason to wrap the extra layer as a `Model`

# Development Notes:

## Creating the optigraph backend
- Adding variables to nodes and edges updates the corresponds backend(s)
- We create a final optigraph backend using contained subgraphs if needed
- We can optionally choose to build an optigraph using a single backend
	- `add_subgraph!(graph; modular=False)` creates a graph that points to the parent backend
	- `add_subgraph!(graph, sg)` uses the subgraph backend. same as `add_subgraph!(graph, modular=True)`.
	- links between subgraphs use referenced variables if all one backend, otherwise creates new references

- node and edge backends contain their 'truth' information. A node or edge may use a parent graph 
as the backend as opposed to its source graph. this is purely for performance and not necessarily required.

## Creating JuMP models
- It should be  possible to obtain a JuMP Model from an optigraph. this performs necessary copy functions
- `model = jump_model(graph)`

## Using hypergraphs
- Looking into HyperGraphs.jl and extend it with anything we already did for orginal Plasmo.jl


# Other Notes:
## Memory Efficiency
- creating a new dictionary for each node does not scale. We need to keep the amount of node data containers to an absolute minimum and levarage aggregate data structures where possible
- we store such containers on the node's source graph
- nodes and edges are light-weight in memory. They are associated with variables and constraints through the GraphBackend

# OptiGraph Backends

## OptiGraph Backends
- MOI Backend (standard solvers)
- GOI Backend (graph-based solvers)

## Distributed OptiGraph Backends
- MOI Backends (coordinate standard solvers)
- GOI Backends (coordinate graph-based solvers)
- DGOI Backend (hookup a distributed solver)

# TODO
- build backend from multiple graphs
- standard hypergraph interface