# Motivation
- The idea for the new Plasmo.jl is to create our own MOI interface for the OptiGraph

## Why we can't use JuMP.Model for an OptiGraph backend
- No way to handle linking between subproblems (variables must be owned by their model)
- Less prone to user 'messing things up' by working directly with 'Model'
- More flexibility creating our own MOI wrapper: We could use either MOI or GOI backends

# Development Notes:

## Creating the optigraph backend
- Adding variables to nodes and edges updates the corresponds backend(s)
- We create a final optigraph backend using contained subgraphs if needed
- We can optionally choose to build an optigraph using a single backend
	- `add_subgraph!(graph; modular=False)` creates a graph that points to the parent backend
	- `add_subgraph!(graph, sg)` uses the subgraph backend. same as `add_subgraph!(graph, modular=True)`.
	- links between subgraphs use referenced variables if all one backend, otherwise creates new references

## Creating JuMP models
- It should be  possible to obtain a JuMP Model from an optigraph. this performs necessary copy functions
- `model = jump_model(graph)`

## Using hypergraphs
- Looking into HyperGraphs.jl and extend it with anything we already did for orginal Plasmo.jl


# Other Notes:
## Memory Efficiency
- creating a new dictionary for each node does not scale. We need to keep the amount of node data containers to an absolute minimum and levarage aggregate data structures where possible
- we store such containers on the node's source graph
- nodes and edges are light-weight in memory. They are associated with variables and constraints through the GraphBackend


# OptiGraph Backends

## OptiGraph Backends
- MOI Backend (standard solvers)
- GOI Backend (graph-based solvers)

## Distributed OptiGraph Backends
- MOI Backends (coordinate standard solvers)
- GOI Backends (coordinate graph-based solvers)
- DGOI Backend (hookup a distributed solver)
